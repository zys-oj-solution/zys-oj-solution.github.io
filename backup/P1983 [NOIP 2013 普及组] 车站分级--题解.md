# P1983 [NOIP 2013 普及组] 车站分级
## 题目大意
铁路线上有n个火车站，每个车次停靠的车站必须覆盖其行驶区间内所有级别大于等于该车站的站点。求这些车站至少分为几个级别 。

## 解题思路
既然一条线路经过的都要大于等于某个等级，那剩下的就都小于这个等级。
看似一句废话，实际 ~~就是废话~~ 思路就有了。
我们可以发现，线路上停靠的点的等级都比未停靠的点的等级高(此为数量关系)。
故将本题转化为**拓扑排序求最长路径**问题。每个车站的级别必须满足以下约束：
1. 若某车站未被某车次停靠，则其级别必须小于该车次行驶区间内所有停靠车站的级别。
2. 若某车站被某车次停靠，则其级别必须大于该车次行驶区间内所有未被停靠车站的级别 。

### 关键步骤
1. **建图**：对每趟车次，行驶区间内的所有未停靠车站向所有停靠车站连边，表示前者级别必须小于后者。
2. **拓扑排序**：计算每个节点的最长路径长度，最终答案为最长路径长度加1。

## 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std; 
const int MAXN = 1010;
int main() {
    int n, m;  //定义变量 n 表示车站数，m 表示车次数。 
    cin >> n >> m;
    vector<vector<int> > adj(n + 1); //表示每个车站指向其他哪些等级更高的车站。
    vector<int> indegree(n + 1, 0); //数组，记录每个节点有多少前驱节点(对于一个有向图中的边 u → v，节点 u 被称为节点 v 的前驱节点)。
    vector<vector<bool> > has_edge(n + 1, vector<bool>(n + 1, false));  //边存在标记数组，防止重复添加相同的边，避免内存溢出。 
    for (int i = 0; i < m; i++) { //循环读取每趟车次的信息。
        int s_i; //定义当前车次的停靠站个数变量。
        cin >> s_i;
        vector<int> stops(s_i); //存储当前车次的所有停靠站编号。
        for (int j = 0; j < s_i; j++) { //循环读取当前车次的每个停靠站。
            cin >> stops[j]; //输入每个停靠站编号。 
        }
        int s = stops[0], t = stops.back(); //获取当前车次的起始站 s 和终点站 t。
        set<int> stop_set(stops.begin(), stops.end()); //将停靠站存入集合，便于快速查找是否已停靠。
        for (int y = s; y <= t; y++) { //遍历当前车次行驶区间内的所有车站。 
            if (stop_set.find(y) == stop_set.end()) {
                for (int k = 0; k < stops.size(); k++) {
                    int x = stops[k];
                    if (!has_edge[y][x]) {
                        adj[y].push_back(x);
                        has_edge[y][x] = true;
                        indegree[x]++;
                    }
                }
            }
        }
    }
/*
如果车站 y 没有被停靠， 
就遍历当前车次所有停靠站。 
取出当前停靠站 x。 
如果还没有从 y 到 x 的边。
新增边 y,x，表示 y 的等级必须小于 x。
标记这条边已经存在。 
更新目标节点 x 。
*/
    vector<int> dist(n + 1, 0);
    queue<int> q;
    for (int i = 1; i <= n; i++) {
        if (indegree[i] == 0) {
            q.push(i);
        }
    }
/*
初始化每个节点的距离值为 0，表示该节点的最长路径长度。 
定义队列用于拓扑排序。
遍历所有车站。
如果当前节点入度为 0，说明没有前驱节点，可以加入队列。
*/
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int j = 0; j < adj[u].size(); j++) {
            int v = adj[u][j];
            if (dist[v] < dist[u] + 1) {
                dist[v] = dist[u] + 1;
            }
            indegree[v]--;
            if (indegree[v] == 0) {
                q.push(v);
            }
        }
    }
/*
开始进行拓扑排序。
取出队列中的节点 u。
删除队首元素(删除队首元素是为了标记当前节点已经处理完毕 ，防止重复处理，并让下一个节点进入处理流程。 )
遍历 u 的所有后继节点(后继节点：与前驱节点相对)。
获取后继节点 v。
如果通过 u 可以获得更长的路径，更新路径最大长度(类似打擂台)
删除 u -> v 这条边，相当于减少 v 的入度。
如果 v 的入度变为 0，说明所有前驱节点都已处理完成。 
将 v 加入队列继续处理。 
*/
    int max_level = 0;
    for (int i = 1; i <= n; i++) {
        max_level = max(max_level, dist[i]);
    }
    cout << max_level + 1 << endl;
    return 0;
}
/*
初始化最长路径长度为 0。 (因为我们不知道哪个车站的路径最长，需要从头开始比较每一个 dist[i]，而且也是因为我们所有的 dist[i] 都 >= 0。)
遍历所有车站，更新最长路径长度。
输出其+1的结果，完结撒花！(因为拓扑排序中求出的最长路径长度表示该节点在整个等级链中所处的位置（从 0 开始），因此要加1才能得到它的实际等级(即最少划分的等级数)。
*/
```
## 需要注意的点
1. **边去重**：使用 `has_edge[y][x]` 避免重复添加相同边，降低时空复杂度。
2. **兼容性处理**：用 `set` 替代 `unordered_set` 以防止洛谷编译器崩溃自动切换至98版本导致兼容性问题。

## 复杂度分析
- **时间复杂度**：`Gmeek-html<img src="https://static.codemao.cn/flowchunkflex/HkTYsamLxx.png?hash=FuhknwX_c1JUlvdsdes5lQssG3UI">` ，其中边去重机制显著降低了实际边数。
- **空间复杂度**：`Gmeek-html<img src="https://static.codemao.cn/flowchunkflex/HJD73pX8ex.png?hash=Fr9Tk08DXnGyFFEhJDc1AxRaGLf5">` ，主要由邻接表和边标记数组产生时空复杂度，故不优化代码将导致内存溢出。
我之前是这么写的：
```cpp
for (int y = s; y <= t; y++) {
    if (stop_set.find(y) == stop_set.end()) {
        for (int k = 0; k < stops.size(); k++) {
            int x = stops[k];
            adj[y].push_back(x);
            indegree[x]++;
        }
    }
}
```
> [!WARNING]
>  若这么写，在极端情况下（如 s=1, t=1000 且 stops.size()=500）会导致邻接表中出现 500 * 500 = 250,000 条边。若 m=1000，则总边数可达 2.5亿 ，导致内存溢出。