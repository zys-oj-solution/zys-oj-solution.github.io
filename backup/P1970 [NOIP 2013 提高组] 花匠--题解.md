## 题目大意

你有一排花，每株花有高度。你可以移走一些花，只留下一部分。要求剩下的花的高度必须满足以下两个条件之一：

- **波峰波谷交替（上下起伏）**
  - 比如：低 → 高 → 低 或者 高 → 低 → 高
- 最终目标是：**最多能留下多少株花？**

---

## 解法思路

统计**高度变化的“拐点”数量**，也就是在“上升→下降”或“下降→上升”的地方计数。

这其实是一个**贪心算法**的问题。

---

## 举个例子
比如输入是：

```
5
5 3 2 1 2
```

花的高度是：`5 3 2 1 2`

我们来看它的变化趋势：

- 5 → 3：下降
- 3 → 2：继续下降 （不是拐点）
- 2 → 1：继续下降 
- 1 → 2：上升 （出现了从降变升的拐点）

所以我们可以保留：
- 第1株（5）
- 第4株（1）
- 第5株（2）

它们构成一个下坡后上坡的结构，满足条件。

输出就是 `3`。

---

## 逐句代码讲解

```cpp
#include <bits/stdc++.h>
using namespace std;
```
引入万能头文件，包含所有常用库函数；使用标准命名空间。

```cpp
int n,m,t=0,ans=1,cnt=-1;
```
定义变量：
- `n`：总共有多少株花；
- `m`：当前读入的花的高度；
- `t`：前一株花的高度，初始为第一个花的高度；
- `ans=1`：至少可以留一株花，所以答案初始化为1；
- `cnt=-1`：状态标记，用来记录当前是上升还是下降趋势。

```cpp
int main() {
	cin>>n>>m; 
	t=m;
```
主函数开始，先读入第一株花的高度，并保存到 `t` 中。

```cpp
	for (int i = 2; i <= n; i++) {
		cin>>m;
```
从第2株花开始循环处理每一株花。

```cpp
		if (m > t && cnt != 1) {
			cnt = 1;
			ans++;
		}
```
如果当前花比上一株高，并且之前不是上升趋势（`cnt != 1`），说明这是一个新的上升趋势的起点，出现了一个“拐点”，于是把 `ans++`，并更新状态为“上升”。

```cpp
		else if (m < t && cnt) {
			cnt = 0;
			ans++;
		}
```
如果当前花比上一株矮，并且之前不是下降趋势（`cnt != 0`），说明这是新的下降趋势的起点，也加一个拐点。

```cpp
		t=m;
```
更新上一次的高度为当前花的高度。

```cpp
	}
	cout<<ans;
	return 0;
}
```
循环结束，输出结果。

---

## 时间复杂度分析

- 整个程序只遍历一遍数组；
- 没有任何嵌套循环；
- 所以时间复杂度是：O(n) 

对于题目给出的数据范围限制来说，完全可以通过。

---

## 总结

| 内容 | 说明 |
|------|------|
| 题型 | 贪心[（练题传送门）](https://www.luogu.com.cn/training/110)+模拟 |
| 时间复杂度 | O(n) |
| 空间复杂度 | O(1) |
| 关键点 | 统计“上下起伏”的拐点 |
| AC技巧 | 只要判断前后趋势是否变化即可 |
